
// Here the  merchantTransactionId id means a unique id generated by us (Merchant) so that we can identify the transaction
// in the response received from phonepe we have a transactionId it is generated by phonepe to identify transaction
const express = require("express");
const router = express.Router();
const axios = require("axios");
const crypto = require("crypto");
const logger = require("firebase-functions/logger");
const { getFirestore, FieldValue, admin,Timestamp } = require("firebase-admin/firestore");
const db = getFirestore();

// ENVs
const PHONEPE_SALT_KEY = process.env.PHONEPE_SALT_KEY;
const PHONEPE_MERCHANT_ID = process.env.PHONEPE_MERCHANT_ID;
const PHONEPE_URL = process.env.PHONEPE_API_URL;
const FRONTEND_URL = process.env.REACT_APP_FRONTEND_URL;
const API_URL = process.env.REACT_APP_API_URL;



function generateXVerifyHeader(payload, endpoint) {
  const string = payload + endpoint + PHONEPE_SALT_KEY;
  const sha256 = crypto.createHash("sha256").update(string).digest("hex");
  return sha256 + "###" + 1;
}

router.post("/", async (req, res) => {
if (req.query && req.query.id) {
   try {
    const merchantTransactionId = req.query.id;
    const merchantId = PHONEPE_MERCHANT_ID;

    const keyIndex = 1;

    const string =
      `/pg/v1/status/${merchantId}/${merchantTransactionId}` + PHONEPE_SALT_KEY;
    const sha256 = crypto.createHash("sha256").update(string).digest("hex");
    const checksum = sha256 + "###" + keyIndex;

    const options = {
      method: "get",
      url: `${PHONEPE_URL}/status/${merchantId}/${merchantTransactionId}`,
      headers: {
        accept: "application/json",
        "Content-Type": "application/json",
        "X-VERIFY": checksum,
        "X-MERCHANT-ID": merchantId,
      },
    };

    // Await the API response
    const response = await axios(options);
    if (
      response?.data?.success === true &&
      response?.data?.code === "PAYMENT_SUCCESS"
    ) {
      const paymentDetails = response.data;

      console.log("Payment Details:", paymentDetails);

      try {
        const docSnap = await db
          .collection("transactions")
          .doc("payments")
          .collection("records")
          .doc(merchantTransactionId)
          .get();

        const globalOrderDetails = docSnap.data();

        if (!globalOrderDetails) {
          return res.status(404).send("orderDetails not found");
        }

        // Combine orderDetails with paymentDetails under the key 'paymentData'
        const combinedDetails = {
          ...globalOrderDetails,
          paymentData: paymentDetails, // Nest paymentDetails under the key 'paymentData'
        };

        console.log(
          "Combined Order and Payment Details:",
          JSON.stringify(combinedDetails, null, 2)
        );
        // Await order creation API call
        const orderResponse = await axios.post(
          `${API_URL}/orders/createOrder`,
          combinedDetails
        );
        logger.log("Order Creation Response:", orderResponse.data);

        await db
          .collection("transactions")
          .doc("payments")
          .collection("records")
          .doc(merchantTransactionId)
          .delete();
        // Extracting productIds
        const selectedProductIds = globalOrderDetails.orderedProducts.map(
          (product) => product.productId
        );
        console.log(
          "Selected Product Ids for Batch delete",
          selectedProductIds
        );
        try {
          const response = await axios.post(`${API_URL}/cart/batch-delete`, {
            uid: globalOrderDetails.uid,
            itemIds: selectedProductIds,
          });
        } catch (error) {
          logger.error("Error in batch delete", error);
        }
        const url = `${FRONTEND_URL}/paymentSuccess`;
        return res.redirect(url);
      } catch (error) {
        logger.error("Error while creating order:", error);
        const url = `${FRONTEND_URL}/cart`;
        return res.redirect(url);
      }
    } else {

      const transactionRef = db
  .collection("transactions")
  .doc("payments")
  .collection("records")
  .doc(merchantTransactionId);


  await transactionRef.update({
 status: response.data
});
      const url = `${FRONTEND_URL}/cart`;
      return res.redirect(url);
    }
  } catch (error) {
    logger.error("Error in /status route:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
}

 if (req.body && Object.keys(req.body).length > 0) {
     try {
    const {
      name,
     merchantTransactionId,
      uid,
      modeOfPayment,
      totalAmount,
      payableAmount,
      discount,
      lushioCurrencyUsed,
      couponCode,
      address,
      orderedProducts,
      onlinePaymentDiscount,
      couponDiscount,
      lushioCashBack,
    } = req.body;
 // const merchantTransactionId = transactionId;
    // Separate global order details
    let globalOrderDetails = {
      uid,
      modeOfPayment,
      totalAmount,
      payableAmount,
      discount,
      lushioCurrencyUsed,
      couponCode,
      address,
      orderedProducts,
      onlinePaymentDiscount,
      couponDiscount,
      lushioCashBack,
    };
  
    const data = {
      merchantId: PHONEPE_MERCHANT_ID,
      merchantTransactionId: merchantTransactionId ,
      merchantUserId: uid,
      name: name,
      amount: payableAmount * 100,
      redirectUrl: `${API_URL}/payment/?id=${merchantTransactionId }`,
      redirectMode: "POST",
      paymentInstrument: {
        type: "PAY_PAGE",
      },
    };

    try {
      await db
        .collection("transactions")
        .doc("payments")
        .collection("records")
        .doc(merchantTransactionId )
        .set({
    createdAt: FieldValue.serverTimestamp(),
    ...globalOrderDetails,
  });
    } catch (error) {
      console.log(error);
    }

    logger.log("backend order", globalOrderDetails);
    logger.log("data", data);
    const KeyIndex = 1;

    // Base64 encode the payload
    const payload = JSON.stringify(data);
    const payloadMain = Buffer.from(payload).toString("base64");
    const checksum = generateXVerifyHeader(payloadMain, "/pg/v1/pay");
    const prod_URL = `${PHONEPE_URL}/pay`;

    const option = {
      method: "POST",
      url: prod_URL,
      headers: {
        accept: "application/json",
        "Content-Type": "application/json",
        "X-VERIFY": checksum,
      },
      data: {
        request: payloadMain,
      },
    };
    try {
  const response = await axios.request(option);
  return res.json(response.data); // Return ensures no further execution
} catch (error) {
  logger.log("Error in / route inner catch", error);
  return res.status(500).json({ error: error.message });
}
  } catch (error) {
    logger.log("Error in / route outer catch", error);
  }
  }
});

// Route: Refund Transaction
router.post("/refund", async (req, res) => {
  try {
    const {
      uid,
      oid,
      // merchantTransactionId,
      amount,
    } = req.body;
    const merchantTransactionId = "R" + Date.now();
    // merchantTransactionId is R+Date.now()
    // Validate required fields
    if (!oid || !uid || !amount) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields: uid, oid, amount",
      });
    }
    const orderRef = db.collection("orders").doc(oid);
    const orderDoc = await orderRef.get();
    // const userRef = db.collection("users").doc(uid);
if(amount<=0){
    return res
        .status(404)
        .json({ success: false, message: "Amount must be greater than zero" });
}
    if (!orderDoc.exists) {
      return res
        .status(404)
        .json({ success: false, message: "Order not found." });
    }

    const orderData = orderDoc.data();
    if (orderData.uid !== uid) {
      return res
        .status(403)
        .json({ success: false, message: "Unauthorized access." });
    }
    if (!orderData.paymentData) {
      return res.status(405).json({
        success: false,
        message: "Online Payment details not found for this order",
      });
    }
     if (!orderData.paymentData.transactionId) {
      return res.status(405).json({
        success: false,
        message: "Online Payment details  found but transactionId not found for this order",
      });
    }

    // Prepare payload
    const payload = {
      merchantId: PHONEPE_MERCHANT_ID,
      merchantUserId: uid,
      // originalTransactionId: "T7850590068188104",
      originalTransactionId: orderData.paymentData.transactionId,
      merchantTransactionId: merchantTransactionId,
      amount: parseInt(amount) * 100,
      callbackUrl: `${FRONTEND_URL}/cart`,
    };
 try {
      await db
        .collection("transactions")
        .doc("refunds")
        .collection("records")
        .doc(merchantTransactionId)
        .set({
          uid: uid,
          createdAt: FieldValue.serverTimestamp(),
          orderId: oid,
          payload: payload,
        });
    } catch (error) {
      console.log(error);
    }
    console.log("Refund Payload:", payload);

    // Encode payload
    const encode = Buffer.from(JSON.stringify(payload)).toString("base64");

    // Generate X-VERIFY header
    const xVerifyHeader = generateXVerifyHeader(encode, "/pg/v1/refund");

    // Make refund API call
    const refundResponse = await axios.post(
      `${PHONEPE_URL}/refund`,
      {
        request: encode,
      },
      {
        headers: {
          "Content-Type": "application/json",
          accept: "application/json",
          "X-VERIFY": xVerifyHeader,
        },
      }
    );

    console.log("Refund API Response:", refundResponse.data);
    try {
      await db
        .collection("transactions")
        .doc("refunds")
        .collection("records")
        .doc(merchantTransactionId)
        .update({
          data: refundResponse.data,
        });
    } catch (error) {
      console.log(error);
    }
    if (orderDoc.exists) {
      try {
        await orderRef.update({
          [`refundDetails.${merchantTransactionId}`]: {
            data: refundResponse.data,
            payload: payload,
            createdAt: FieldValue.serverTimestamp(),
          },
        });
      } catch (e) {
        console.log(e);
      }
    }
    res.json({
      data: refundResponse.data,
      payload: payload,
    });
  } catch (error) {
    console.error("Refund Error: ", error.response?.data || error.message);
     // Prepare error response to store
  const errorDetails = {
    error: error.response?.data || error.message,
   
  };

  // Store error in refund record
  try {
    await db
      .collection("transactions")
      .doc("refunds")
      .collection("records")
      .doc(merchantTransactionId)
      .update(errorDetails);
  } catch (e) {
    console.log("Error writing to refund record:", e.message);
  }

    res.status(500).json({
      success: false,
      message: "Refund request failed",
      error: error.response?.data || error.message,
    });
  }
});



// To check status of a transaction
router.post("/status-verify", async (req, res) => {
  try {
    const merchantTransactionId = req.query.id;
    const merchantId = PHONEPE_MERCHANT_ID;

    const keyIndex = 1;

    const string =
      `/pg/v1/status/${merchantId}/${merchantTransactionId}` + PHONEPE_SALT_KEY;
    const sha256 = crypto.createHash("sha256").update(string).digest("hex");
    const checksum = sha256 + "###" + keyIndex;

    const options = {
      method: "get",
      url: `${PHONEPE_URL}/status/${merchantId}/${merchantTransactionId}`,
      headers: {
        accept: "application/json",
        "Content-Type": "application/json",
        "X-VERIFY": checksum,
        "X-MERCHANT-ID": merchantId,
      },
    };

    const response = await axios(options);
    return res.status(200).json(response.data);
  } catch (error) {
    logger.error("Error in /status route:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});
module.exports = router;
